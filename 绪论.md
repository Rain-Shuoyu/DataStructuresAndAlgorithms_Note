# 绪论



### 渐近时间复杂度表示方法
- 大O表示法：若存在一个常数 $c > 0$ 和整数 $n_0 > 0$ ，使得对于所有 $n \geq n_0$ 满足 $T(n) \leq c \cdot f(n)$ 则称 $T(n) = O(f(n))$。大O表示法为待求解表达式提供了一个上界，描述其最多消耗 $f(n)$ 数量级的时间。
- 大$\Omega$表示法： 若存在一个常数 $c > 0$ 和整数 $n_0 > 0$ ，使得对于所有 $n \geq n_0$ 满足 $T(n) \geq c \cdot f(n)$ 则称 $T(n) = \Omega(f(n))$。大$\Omega$表示法为待求解表达式提供了一个下界，但这个下界不一定是下确界，我们可能找到其他的 $g(n), h(n)$，使得 $T(n) \geq c \cdot f(n) \geq c \cdot g(n) \geq c \cdot h(n)$。
- 大$\Theta$表示法：若存在一组常数$c_1, \ c2 > 0$和整数$n_0 > 0$，使得对于所有的$n \geq n_0$ 满足$ c_1 \cdot f(n) \geq T(n) \geq c_2 \cdot f(n)$。由于$T(n)$的上下界都被 $f(n)$ 的某个常数倍所限制，故 $T(n)$ 与 $f(n)$ 应该属于同一个数量级，且 $T(n) = \Theta(f(n)) \iff T(n) = O(f(n)), \ T(n) = \Omega(f(n))$。

- 小o表示法：对任意 $c>0$ 都存在一个整数 $n_0  > 0$ 满足对所有 $n \geq n_0$ 都有 $T(n) < c \cdot f(n)$。此时表示的是“严格小于”，即$T(n)$的数量级小于$f(n)$，如$n^{k} = o(n^{k+1})$。

### 最好、最坏和平均时间复杂度

- 最好时间复杂度：在最理想的情况下，算法所能达到的最高效率，此时的时间复杂度成为最好时间复杂度。
- 最坏时间复杂度：算法遭遇到最糟糕的情况，此时的时间复杂度为最坏时间复杂度。
- 平均时间复杂度：算法在所有可能的输入下的平均效率。再计算平均情况时间复杂度时，通常假设所有输入出现的概率符合特定的分布，再计算时间复杂度的平均值。

### 空间复杂性的度量

算法执行时的空间消耗包括程序代码本身所占的空间、存储数据所占的空间和中间过程所使用的辅助空间等。算法的空间复杂性通常是度量他所使用的辅助空间大小和数据规模$n$之间的关系，通常也是用渐近复杂度表示，与时间复杂性相似。

### 常用的时间复杂度函数

通常采用的时间复杂度函数有：

- $O(log(n))$
- $O(n)$
- $O(nlog(n))$
- $O(n^2)$
- $O(n^3)$
- $O(2^n)$
- $O(n!)$
- $O(n^n)$

当$n$逐渐增大时，它们的时间复杂度由上到下依次增大。

### 渐近表示法的计算

**定理1-1（求和定理）** 假设两个已知的程序段的时间复杂度分别为 $T_1(n) = O(f(n)), \ T_2(n) = O(g(n))$，那么顺序组合这两个程序段之后，得到的新程序段的时间复杂度为 $(T_1 + T_2)(n) = O(max\{f(n),g(n)\}) $

**定理1-2（求积定理）** 假设假设两个已知的程序段的时间复杂度分别为 $T_1(n) = O(f(n)), \ T_2(n) = O(g(n))$，那么交叉乘法组合这两个程序段之后，得到的新程序段的时间复杂度为 $(T_1 \times T_2)(n) = O(f(n)\times g(n)) $

### 算法优化